### 1.1.1 冒泡排序

----

**冒泡排序的基本思想是，每次比较相邻的两个元素的大小，如果顺序错误就交互位置**

例如 ： 1 3 2 5 11 9 6 按照从小到大排序

第 1 次: 1 < 3 顺序没问题 → 比较下一组

2: 3 > 2 顺序不对，则调换位置成为 1 2 3 5 11 9 6 → 然后再比较下一组

3: 3 < 5 顺序没问题 → 比较下一组

4: 5 < 11 顺序没问题 → 比较下一组

5: 11 > 9 顺序不对，则调换位置成为 1 2 3 5 9 11 6 → 然后再比较下一组

6: 11 >6 顺序不对，则调换位置成为 1 2 3 5 9 6 11 → 然后再比较下一组

7: 没有多余数字，11 则为最大数字，重新再进行一轮排序

8: 1 < 2 顺序没问题 → 比较下一组

9：2 < 3 顺序没问题 → 比较下一组

10: 3 < 5 顺序没问题 → 比较下一组

11: 5 < 9 顺序没问题 → 比较下一组

12: 9 < 6  顺序不对，则调换位置成为 1 2 3 5 6 9 11 → 然后再比较下一组

13: 9 < 11 顺序没问题 → 比较下一组   **// 实际到这个位置已经不需要比较了，因为经过第一轮排序后最后一个必定是最大，同理经过第二轮排序后，倒数第二个必定是第二大，第三轮后倒数第三个必定第三大，都无序比较。后面以此类推...**

14  没有多余数字，9 则为最大数字，重新再进行一轮排序。

事实上，在这个情况下，排序已经完成，但是并不能保证所有的情况下都能两轮完成排序，所以还需要继续执行，执行的次数为： **数组总数 - 1** 次。


-----

最后总结一下就是，如果 n 个数进行排序，就需要从第 0 个数字到 n 进行冒泡交换，交换一轮完成之后就可以再次执行第二轮，一直到执行 n - 1 轮，排序就完成了。js 代码如下：

```
// 确定数组
const a = [1, 3, 0, 2, 4, 5, 6, 1, 213, 325, 6]

const bubbleSort = (arr)=> {
  // 获取数组个数
  const length = arr.length
  for (let i =0;i < arr.length; i++) {
  // 一共执行 i = length - 1 次排序
    for (let n = 0; n < length-1-i; n++) {
    // 扣除掉每轮不需要比较的数组（第一轮倒数第一个，第二轮倒数第二个，第三轮...）
      if (arr[n] > arr[n+1]) {
      // 如果前面比后面大，调换位置，用了 es 6 解构赋值语法。 
        [arr[n], arr[n+1]] = [arr[n+1], arr[n]]
      }
    }
  }
  return a
}
bubbleSort(a)
```

详细代码地址为 [Google](https://github.com/jinzhuming/Algorithm/blob/master/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/index.html/)